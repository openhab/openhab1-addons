/**
 * Copyright (c) 2010-2015, openHAB.org and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
@GenModel(literalsInterface="true", loadInitialization="false", adapterFactory="false")
package org.openhab.binding.tinkerforge.internal.model

import com.tinkerforge.Device
import com.tinkerforge.IPConnection
import org.slf4j.Logger
import com.tinkerforge.BrickServo
import com.tinkerforge.BrickletDualRelay
import com.tinkerforge.BrickletHumidity
import com.tinkerforge.BrickletDistanceIR
import com.tinkerforge.BrickletTemperature
import com.tinkerforge.BrickletBarometer
import com.tinkerforge.BrickletAmbientLight
import com.tinkerforge.BrickDC
import java.util.concurrent.atomic.AtomicBoolean
import com.tinkerforge.BrickletLCD20x4
import com.tinkerforge.BrickletIndustrialQuadRelay
import com.tinkerforge.BrickletIndustrialDigitalIn4
import org.openhab.binding.tinkerforge.internal.types.TinkerforgeValue
import org.openhab.binding.tinkerforge.internal.types.DecimalValue
import org.openhab.binding.tinkerforge.internal.types.OnOffValue
import org.openhab.binding.tinkerforge.internal.types.HighLowValue
import org.openhab.binding.tinkerforge.internal.types.PercentValue
import org.openhab.binding.tinkerforge.internal.types.DirectionValue
import org.openhab.binding.tinkerforge.internal.types.HSBValue
import com.tinkerforge.BrickletIO16
import com.tinkerforge.BrickletRemoteSwitch
import com.tinkerforge.BrickletMotionDetector
import com.tinkerforge.BrickletMultiTouch
import com.tinkerforge.BrickletTemperatureIR
import com.tinkerforge.BrickletSoundIntensity
import com.tinkerforge.BrickletMoisture
import com.tinkerforge.BrickletDistanceUS
import com.tinkerforge.BrickletVoltageCurrent
import com.tinkerforge.BrickletTilt
import com.tinkerforge.BrickletIO4
import com.tinkerforge.BrickletIndustrialDigitalOut4
import com.tinkerforge.BrickletHallEffect
import com.tinkerforge.BrickletSegmentDisplay4x7
import com.tinkerforge.BrickletLEDStrip
import com.tinkerforge.BrickletJoystick
import com.tinkerforge.BrickletLinearPoti
import com.tinkerforge.BrickletDualButton
import com.tinkerforge.BrickletPTC
import com.tinkerforge.BrickletIndustrialDual020mA
import com.tinkerforge.BrickletSolidStateRelay
import org.openhab.core.library.types.HSBType
import org.openhab.core.library.types.UpDownType
import org.openhab.core.library.types.PercentType
import org.openhab.core.library.types.IncreaseDecreaseType
import java.math.BigDecimal
import org.openhab.binding.tinkerforge.internal.config.DeviceOptions

/**
 * @author Theo Weiss
 * @since 1.3.0
 */

type MIPConnection wraps IPConnection
type MTinkerDevice wraps Device
type MLogger wraps Logger
type MAtomicBoolean wraps AtomicBoolean
type MTinkerforgeDevice wraps Device
type MTinkerBrickDC wraps BrickDC
type MTinkerBrickletDualRelay wraps BrickletDualRelay
type MTinkerBrickletIndustrialQuadRelay wraps BrickletIndustrialQuadRelay
type MTinkerBrickletIndustrialDigitalIn4 wraps BrickletIndustrialDigitalIn4
type MTinkerBrickletIndustrialDigitalOut4 wraps BrickletIndustrialDigitalOut4
type SwitchState wraps OnOffValue
type DigitalValue wraps HighLowValue
type HSBValue wraps HSBValue
type TinkerBrickletIO16 wraps BrickletIO16
type MTinkerBrickServo wraps BrickServo
type MTinkerforgeValue wraps TinkerforgeValue
type MDecimalValue wraps DecimalValue
type MTinkerBrickletHumidity wraps BrickletHumidity
type MTinkerBrickletDistanceIR wraps BrickletDistanceIR
type MTinkerBrickletTemperature wraps BrickletTemperature
type MTinkerBrickletBarometer wraps BrickletBarometer
type MTinkerBrickletAmbientLight wraps BrickletAmbientLight
type MTinkerBrickletLCD20x4 wraps BrickletLCD20x4
type TinkerBrickletRemoteSwitch wraps BrickletRemoteSwitch
type TinkerBrickletMotionDetector wraps BrickletMotionDetector
type TinkerBrickletMultiTouch wraps BrickletMultiTouch
type TinkerBrickletTemperatureIR wraps BrickletTemperatureIR
type TinkerBrickletSoundIntensity wraps BrickletSoundIntensity
type TinkerBrickletMoisture wraps BrickletMoisture
type TinkerBrickletDistanceUS wraps BrickletDistanceUS
type TinkerBrickletVoltageCurrent wraps BrickletVoltageCurrent
type TinkerBrickletTilt wraps BrickletTilt
type TinkerBrickletIO4 wraps BrickletIO4
type TinkerBrickletHallEffect wraps BrickletHallEffect
type TinkerBrickletSegmentDisplay4x7 wraps BrickletSegmentDisplay4x7
type TinkerBrickletLEDStrip wraps BrickletLEDStrip
type BrickletJoystick wraps BrickletJoystick
type TinkerBrickletLinearPoti wraps BrickletLinearPoti
type TinkerBrickletDualButton wraps BrickletDualButton
type TinkerBrickletPTC wraps BrickletPTC
type TinkerBrickletIndustrialDual020mA wraps BrickletIndustrialDual020mA
type TinkerBrickletSolidStateRelay wraps BrickletSolidStateRelay
type HSBType wraps HSBType
type UpDownType wraps UpDownType
type PercentValue wraps PercentValue
type DeviceOptions wraps DeviceOptions
type PercentType wraps PercentType
type IncreaseDecreaseType wraps IncreaseDecreaseType
type DirectionValue wraps DirectionValue
type Enum wraps Enum

class Ecosystem {
	MLogger logger
	contains MBrickd[] mbrickds opposite ecosystem
	op MBrickd getBrickd(String host, int port)
	op MBaseDevice getDevice(String uid, String subId)
	op MSubDevice<?>[] getDevices4GenericId(String uid, String genericId)
	op void disconnect()
}

class MBrickd {
	MLogger logger
	MIPConnection ipConnection
	String host = "localhost"
	int port = "4223"
	String authkey
	DigitalValue isConnected
	boolean autoReconnect = "true"
	boolean reconnected = "false"
	MDecimalValue connectedCounter = "0"
	int timeout = "2500"
	
	op void connect() 
	op void disconnect() 
	op void init()
	contains MDevice<?>[] mdevices opposite brickd
	op MBaseDevice getDevice(String uid)
	container Ecosystem ecosystem opposite mbrickds
}

interface SubDeviceAdmin {
	op void addSubDevice(String subId, String subDeviceType)
}

interface MTFConfigConsumer<TFC>{
	contains TFC tfConfig
}

interface MBaseDevice{
	MLogger logger
	String uid
	// for now poll all devices because at startup time
	// updates are missed by the ui, because binding start
	// can happen before ui start.
	boolean poll = "true"
	MAtomicBoolean enabledA
	op void init()
	op void enable()
	op void disable()
}

interface MDevice<TF extends MTinkerforgeDevice> extends MBaseDevice {
	TF tinkerforgeDevice
	MIPConnection ipConnection
	String connectedUid
	char position
	int deviceIdentifier
	String name
	container MBrickd brickd opposite mdevices
}

interface MSubDeviceHolder<S extends MSubDevice<?>> {
	contains S[] msubdevices opposite mbrick
	op void initSubDevices()
}

interface MActor{
}
interface SwitchSensor {
	SwitchState switchState
    op void fetchSwitchState()
}

interface MSwitchActor extends SwitchSensor{
	op void turnSwitch(SwitchState state)
}

interface ProgrammableSwitchActor extends SwitchSensor{
    op void turnSwitch(SwitchState state, DeviceOptions opts)
}

interface MInSwitchActor extends MSwitchActor{
}

interface GenericDevice {
	String genericDeviceId
}

interface IODevice extends MSubDevice<MBrickletIO16>, GenericDevice {
}

interface MSubDevice<B extends MSubDeviceHolder<?>> extends MBaseDevice{
	String subId
	container B mbrick opposite msubdevices
}

interface CallbackListener {
	long callbackPeriod = "1000"
}

interface InterruptListener {
	long debouncePeriod = "100"
}

interface MSensor<DeviceValue extends MTinkerforgeValue> {
	DeviceValue sensorValue
	op void fetchSensorValue()
}

interface MTextActor{
	String text   
}
interface MLCDSubDevice extends MSubDevice<MBrickletLCD20x4> {
}

interface DigitalActor {
    DigitalValue digitalState
    op void turnDigital(DigitalValue digitalState)
    op void fetchDigitalValue()
}

interface NumberActor {
    op void setNumber(BigDecimal value)
}

interface ColorActor {
	HSBValue color
}

interface ProgrammableColorActor extends ColorActor {
    op void setSelectedColor(HSBType color, DeviceOptions opts)
}

interface SimpleColorActor extends ColorActor {
    op void setSelectedColor(HSBType color)
}

interface MoveActor {
    DirectionValue direction
    op void move(UpDownType direction, DeviceOptions opts)
    op void stop()
    op void moveon(DeviceOptions opts)
}

interface DimmableActor<TC extends DimmableConfiguration>   extends MTFConfigConsumer<TC> {
    BigDecimal minValue
    BigDecimal maxValue
    op void dimm(IncreaseDecreaseType increaseDecrease, DeviceOptions opts)
}

interface SetPointActor<C extends DimmableConfiguration> extends DimmableActor<C> {
    PercentValue percentValue
    op void setValue(BigDecimal newValue, DeviceOptions opts)
    op void setValue(PercentType newValue, DeviceOptions opts)
}

class MBrickletDualButton extends MDevice<TinkerBrickletDualButton>,
	MSubDeviceHolder<DualButtonDevice>{
	readonly String deviceType = "bricklet_dualbutton"
}

interface DualButtonDevice extends MSubDevice<MBrickletDualButton>{

}

class DualButtonButton extends DualButtonDevice, MSensor<SwitchState>,
	MTFConfigConsumer<ButtonConfiguration> {
	String deviceType = "dualbutton_button"
	DualButtonDevicePosition position
}

class DualButtonLed extends DualButtonDevice, DigitalActor,
	MTFConfigConsumer<DualButtonLEDConfiguration> {
	String deviceType = "dualbutton_led"
	DualButtonDevicePosition position
}

class MBrickletLinearPoti extends MDevice<TinkerBrickletLinearPoti>, CallbackListener,
	MTFConfigConsumer<TFBaseConfiguration>, MSensor<MDecimalValue> {
		readonly String deviceType = "bricklet_linear_poti"
}

class MBrickletJoystick extends MDevice<BrickletJoystick>, MSubDeviceHolder<JoystickDevice>,
		 CallbackListener, MTFConfigConsumer<TFBaseConfiguration> {
	readonly String deviceType = "bricklet_joystick"
	
}

interface JoystickDevice extends MSubDevice<MBrickletJoystick>{
	
}

class JoystickXPosition extends JoystickDevice, MSensor<MDecimalValue> {
		readonly String deviceType = "joystick_xposition"
}

class JoystickYPosition extends JoystickDevice, MSensor<MDecimalValue> {
		readonly String deviceType = "joystick_yposition"
}

class JoystickButton extends JoystickDevice, MSensor<SwitchState>,
	MTFConfigConsumer<ButtonConfiguration> {
		readonly String deviceType = "joystick_button"
}

class MBrickServo extends MDevice<MTinkerBrickServo>, MSubDeviceHolder<MServo> {
	readonly String deviceType = "brick_servo"
	op void init(){}
	//int outputVoltage = "5000"
}

class MServo extends MSensor<MDecimalValue>, ProgrammableSwitchActor, MSubDevice<MBrickServo>, 
		MoveActor, SetPointActor<TFServoConfiguration>{
	readonly String deviceType = "servo"
	int velocity = "65535" //max speed, set position immediately
	int acceleration = "65535" // max acceleration, set position immediately
	Short maxPosition = "9000"
	Short minPosition = "-9000"
	int pulseWidthMin = "1000"
	int pulseWidthMax = "2000"
	int period = "19500"
	int outputVoltage =  "5000"
	short targetPosition
	op void init(){}
	op boolean setPoint(Short position, int velocity, int acceleration)
}

class MBrickDC extends MSensor<MDecimalValue>, ProgrammableSwitchActor, MDevice<MTinkerBrickDC>, 
		MoveActor, SetPointActor<TFBrickDCConfiguration>,
	    CallbackListener{
	readonly String deviceType = "brick_dc"
	op void init(){}
    BigDecimal threshold = "10"
    Short maxVelocity = "32767"
    Short minVelocity = "-32767"
	short velocity
	short targetvelocity = "0"
	short currentVelocity
	int acceleration = "10000"
	int pwmFrequency = "15000"
	DCDriveMode driveMode = "BRAKE"
	op boolean setSpeed(Short velocity, int acceleration, String drivemode)
}

class MDualRelayBricklet extends MDevice<MTinkerBrickletDualRelay>,
		MSubDeviceHolder<MDualRelay>{
	readonly String deviceType = "bricklet_dual_relay"
}

class MIndustrialQuadRelayBricklet extends 
			MDevice<MTinkerBrickletIndustrialQuadRelay>,
			MSubDeviceHolder<MIndustrialQuadRelay>{
	readonly String deviceType = "bricklet_quad_relay"
}

class MIndustrialQuadRelay extends MInSwitchActor, 
				MSubDevice<MIndustrialQuadRelayBricklet>{
	readonly String deviceType = "quad_relay"
}

class MBrickletIndustrialDigitalIn4 extends 
		MSubDeviceHolder<MIndustrialDigitalIn>, 
		MDevice<MTinkerBrickletIndustrialDigitalIn4>, InterruptListener,
		MTFConfigConsumer<TFInterruptListenerConfiguration> {
	readonly String deviceType = "bricklet_industrial_digital_4in"
}

class MIndustrialDigitalIn extends MSubDevice<MBrickletIndustrialDigitalIn4>, 
		MSensor<DigitalValue> {
	readonly String deviceType = "digital_4in"
}

class MBrickletIndustrialDigitalOut4 extends MDevice<MTinkerBrickletIndustrialDigitalOut4>,
        MSubDeviceHolder<DigitalActorDigitalOut4>{
	readonly String deviceType = "bricklet_industrial_digital_4out"
}

class DigitalActorDigitalOut4 extends DigitalActor, MSubDevice<MBrickletIndustrialDigitalOut4> {
    int pin
    readonly String deviceType = "digital_4out"
}


class MBrickletSegmentDisplay4x7 extends NumberActor, MDevice<TinkerBrickletSegmentDisplay4x7>{
    readonly String deviceType = "bricklet_segmentdisplay4x7"
}

class MBrickletLEDStrip extends ProgrammableColorActor, MDevice<TinkerBrickletLEDStrip>,
    MTFConfigConsumer<LEDStripConfiguration>, MSubDeviceHolder<LEDGroup> {
	readonly String deviceType = "bricklet_ledstrip"
	String colorMapping = "rgb"
}

class LEDGroup extends MSubDevice<MBrickletLEDStrip>, SimpleColorActor, MSwitchActor,
	 MTFConfigConsumer<LEDGroupConfiguration>{
	readonly String deviceType = "ledgroup"
}

class DigitalActorIO16 extends DigitalActor, IODevice, MTFConfigConsumer<TFIOActorConfiguration>{
	readonly String deviceType = "io_actuator"
    op void turnDigital(DigitalValue digitalState)
    op void fetchDigitalValue()
	char port
	int pin
	String defaultState
	boolean keepOnReconnect = "false"
}

class MBrickletIO16 extends MDevice<TinkerBrickletIO16>, 
		MSubDeviceHolder<IODevice>, InterruptListener, 
		MTFConfigConsumer<TFInterruptListenerConfiguration>{
	readonly String deviceType = "bricklet_io16"
}

class DigitalSensor extends IODevice, MSensor<DigitalValue>, 
		MTFConfigConsumer<TFIOSensorConfiguration> {
	readonly String deviceType = "iosensor"
	boolean pullUpResistorEnabled
	char port
	int pin
}

class MBrickletIO4 extends MDevice<TinkerBrickletIO4>,
        MSubDeviceHolder<IO4Device>, InterruptListener,
        MTFConfigConsumer<TFInterruptListenerConfiguration> {
   readonly String deviceType = "bricklet_io4"
}

interface IO4Device extends MSubDevice<MBrickletIO4>, GenericDevice {
}

class DigitalSensorIO4 extends IO4Device, MSensor<DigitalValue>, 
        MTFConfigConsumer<TFIOSensorConfiguration> {
    readonly String deviceType = "io4sensor"
    boolean pullUpResistorEnabled
    int pin
}

class DigitalActorIO4 extends DigitalActor, IO4Device, MTFConfigConsumer<TFIOActorConfiguration>{
    readonly String deviceType = "io4_actuator"
    op void turnDigital(DigitalValue digitalState)
    op void fetchDigitalValue()
    int pin
    String defaultState
    boolean keepOnReconnect = "false"
}

class MBrickletMultiTouch extends MDevice<TinkerBrickletMultiTouch>,
        MSubDeviceHolder<MultiTouchDevice>, MTFConfigConsumer<BrickletMultiTouchConfiguration>{
    readonly String deviceType = "bricklet_multitouch"
    Boolean recalibrate
    Short sensitivity
}

class MultiTouchDevice extends  MSubDevice<MBrickletMultiTouch>,
    MSensor<DigitalValue>, MTFConfigConsumer<MultiTouchDeviceConfiguration>{
    int pin
    Boolean disableElectrode
}

class Electrode extends MultiTouchDevice {
    readonly String deviceType = "electrode"
}

class Proximity extends MultiTouchDevice {
    readonly String deviceType = "proximity"
}

class MBrickletMotionDetector extends MDevice<TinkerBrickletMotionDetector>,
                 MSensor<DigitalValue>{
    readonly String deviceType = "motion_detector"
    op void init(){}
}

class MBrickletHallEffect extends MDevice<TinkerBrickletHallEffect>,
        MSensor<DigitalValue>, CallbackListener,
        MTFConfigConsumer<TFBaseConfiguration> {
    readonly String deviceType = "bricklet_halleffect"
    op void init(){}
}

class MDualRelay extends MInSwitchActor, MSubDevice<MDualRelayBricklet>{
	readonly String deviceType = "dual_relay"
}

class MBrickletRemoteSwitch extends MDevice<TinkerBrickletRemoteSwitch>,
	 MSubDeviceHolder<RemoteSwitch>, SubDeviceAdmin, 
	 MTFConfigConsumer<BrickletRemoteSwitchConfiguration>
{
	readonly String deviceType = "bricklet_remote_switch"
    String typeADevices
    String typeBDevices
    String typeCDevices
}
		
interface RemoteSwitch extends MInSwitchActor, MSubDevice<MBrickletRemoteSwitch>{
}

class RemoteSwitchA extends RemoteSwitch, MTFConfigConsumer<RemoteSwitchAConfiguration>{
    readonly String deviceType = "remote_switch_a"	
    Short houseCode
    Short receiverCode
    Short repeats
}

class RemoteSwitchB extends MSensor<MDecimalValue>, RemoteSwitch, DimmableActor<RemoteSwitchBConfiguration>{
    readonly String deviceType = "remote_switch_b"
    Long address
    Short unit
    Short repeats
    Short targetDimmvalue = "0"
}

class RemoteSwitchC extends RemoteSwitch, MTFConfigConsumer<RemoteSwitchCConfiguration>{
    readonly String deviceType = "remote_switch_c"
    String systemCode
    Short deviceCode
    Short repeats
}

class MBrickletHumidity extends MSensor<MDecimalValue>, 
		MDevice<MTinkerBrickletHumidity>, 
		MTFConfigConsumer<TFBaseConfiguration>, CallbackListener {
	String deviceType = "bricklet_humidity"
	BigDecimal threshold = "0.5"
	op void init(){}
}

class MBrickletDistanceIR extends MDevice<MTinkerBrickletDistanceIR>, 
		MSensor<MDecimalValue>, 
		MTFConfigConsumer<TFBaseConfiguration>, CallbackListener {
	readonly String deviceType = "bricklet_distance_ir"
	BigDecimal threshold = "5"
	op void init(){}
}

class MBrickletSolidStateRelay extends MDevice<TinkerBrickletSolidStateRelay>,
	 MSwitchActor {
	readonly String deviceType = "bricklet_solidstaterelay"
	op void init(){}
}

class MBrickletIndustrialDual020mA extends MDevice<TinkerBrickletIndustrialDual020mA>,
	MSubDeviceHolder<Dual020mADevice>, MTFConfigConsumer<TFIndustrialDual020mAConfiguration> {
	readonly String deviceType = "bricklet_industrialdual020ma"
	op void init(){}
}

class Dual020mADevice extends MSubDevice<MBrickletIndustrialDual020mA>, 
	MSensor<MDecimalValue>, CallbackListener, MTFConfigConsumer<TFBaseConfiguration> {
	readonly String deviceType = "industrial020ma_sensor"
	BigDecimal threshold = "1"
	short sensorNum
}

class MBrickletPTC extends MDevice<TinkerBrickletPTC>,
	MTFConfigConsumer<TFPTCBrickletConfiguration>, MSubDeviceHolder<PTCDevice> {
	readonly String deviceType = "bricklet_ptc"
	op void init(){}
}

interface PTCDevice extends MSubDevice<MBrickletPTC> {
}

class PTCTemperature extends PTCDevice, MSensor<MDecimalValue>,
	MTFConfigConsumer<TFBaseConfiguration>, CallbackListener{
	readonly String deviceType = "ptc_temperature"
	BigDecimal threshold = "2"
}

class PTCResistance extends PTCDevice, MSensor<MDecimalValue>,
	MTFConfigConsumer<TFBaseConfiguration>, CallbackListener{
	readonly String deviceType = "ptc_resistance"
	BigDecimal threshold = "2"
}

class PTCConnected extends PTCDevice, MSensor<DigitalValue> {
	readonly String deviceType = "ptc_connected"
}

class MBrickletTemperature extends MDevice<MTinkerBrickletTemperature>, 
		MSensor<MDecimalValue>, MTFConfigConsumer<TFTemperatureConfiguration>, 
		CallbackListener {
	readonly String deviceType = "bricklet_temperature"
	BigDecimal threshold = "0.1"
	boolean slowI2C = "false"
	op void init(){}
}

class MBrickletTemperatureIR extends MDevice<TinkerBrickletTemperatureIR>,
        MSubDeviceHolder<MTemperatureIRDevice> {
    readonly String deviceType = "bricklet_temperatureIR"
}

interface MTemperatureIRDevice extends MSensor<MDecimalValue>, 
        MSubDevice<MBrickletTemperatureIR>, CallbackListener {
    BigDecimal threshold = "0.1"
}

class ObjectTemperature extends MTemperatureIRDevice, 
        MTFConfigConsumer<TFObjectTemperatureConfiguration> {
    readonly String deviceType = "object_temperature"
    int emissivity = "65535"
}

class AmbientTemperature extends MTemperatureIRDevice, 
        MTFConfigConsumer<TFBaseConfiguration>{
    readonly String deviceType = "ambient_temperature"
}

class MBrickletTilt extends MDevice<TinkerBrickletTilt>,
    MSensor<MDecimalValue>{
    readonly String deviceType = "bricklet_tilt"
}

class MBrickletVoltageCurrent extends MDevice<TinkerBrickletVoltageCurrent>,
         MSubDeviceHolder<VoltageCurrentDevice>, 
         MTFConfigConsumer<TFVoltageCurrentConfiguration> {
    readonly String deviceType = "bricklet_voltageCurrent"
    Short averaging = "3"
    Short voltageConversionTime = "4"
    Short currentConversionTime = "4"
}

interface VoltageCurrentDevice extends MSensor<MDecimalValue>, 
        MSubDevice<MBrickletVoltageCurrent>, CallbackListener,
        MTFConfigConsumer<TFBaseConfiguration>{
}

class VCDeviceVoltage extends VoltageCurrentDevice {
    readonly String deviceType = "voltageCurrent_voltage"
    BigDecimal threshold = "20"
}

class VCDeviceCurrent extends VoltageCurrentDevice {
    readonly String deviceType = "voltageCurrent_current"
    BigDecimal threshold = "10"
}

class VCDevicePower extends VoltageCurrentDevice {
    readonly String deviceType = "voltageCurrent_power"
    BigDecimal threshold = "50"
}

class MBrickletBarometer extends MDevice<MTinkerBrickletBarometer>, 
		MSensor<MDecimalValue>, MTFConfigConsumer<TFBaseConfiguration>, 
		MSubDeviceHolder<MBarometerTemperature>, CallbackListener {
	readonly String deviceType = "bricklet_barometer"
	BigDecimal threshold = "1"
	op void init(){}
}

class MBarometerTemperature extends MSensor<MDecimalValue>, 
		MSubDevice<MBrickletBarometer>{
	readonly String deviceType = "barometer_temperature"
	op void init(){}
}

class MBrickletAmbientLight extends MDevice<MTinkerBrickletAmbientLight>, 
		MSensor<MDecimalValue>, MTFConfigConsumer<TFBaseConfiguration>, 
		CallbackListener {
	readonly String deviceType = "bricklet_ambient_light"
	BigDecimal threshold = "1"
	op void init(){}
}

class MBrickletSoundIntensity extends MDevice<TinkerBrickletSoundIntensity>,
        MSensor<MDecimalValue>, MTFConfigConsumer<TFBaseConfiguration>,
        CallbackListener {
    readonly String deviceType = "bricklet_soundintensity"
    BigDecimal threshold = "0"
    op void init(){}
}

class MBrickletMoisture extends MDevice<TinkerBrickletMoisture>,
        MSensor<MDecimalValue>, MTFConfigConsumer<TFMoistureBrickletConfiguration>,
        CallbackListener {
    readonly String deviceType = "bricklet_moisture"
    BigDecimal threshold = "0"
    Short movingAverage = "100"
    op void init(){}
}

class MBrickletDistanceUS extends MDevice<TinkerBrickletDistanceUS>,
        MSensor<MDecimalValue>, MTFConfigConsumer<TFDistanceUSBrickletConfiguration>,
        CallbackListener {
    readonly String deviceType = "bricklet_distanceUS"
    BigDecimal threshold = "0"
    Short movingAverage = "100"
    op void init(){}
}

class MBrickletLCD20x4 extends MDevice<MTinkerBrickletLCD20x4>, MTextActor, 
		MSubDeviceHolder<MLCDSubDevice>{
	readonly String deviceType = "bricklet_LCD20x4"
	op void init(){}
	String positionPrefix = "TFNUM<"
	String positonSuffix = ">"
	boolean displayErrors = "true"
	readonly String errorPrefix = "openhab Error:"
	op boolean clear()
}

class MLCD20x4Backlight extends MInSwitchActor, MLCDSubDevice{
	readonly String deviceType = "backlight"
}

class MLCD20x4Button extends MSensor<SwitchState>, MLCDSubDevice, MTFConfigConsumer<ButtonConfiguration>{
	readonly String deviceType = "lcd_button"
	short buttonNum
}

// configuration model
interface TFConfig {
}

class OHTFDevice<TFC extends TFConfig, IDS extends Enum> {
	String uid
	String subid
	String ohid
	IDS[] subDeviceIds
	contains TFC tfConfig
	container OHConfig ohConfig opposite ohTfDevices
	op boolean isValidSubId (String subId) {
		for (IDS sid : subDeviceIds){
			if (sid.toString.equalsIgnoreCase(subId)){
				return true
			}
		}
		return false
	}
}

class OHTFSubDeviceAdminDevice<TFC extends TFConfig, IDS extends Enum> extends OHTFDevice<TFC, IDS> {
    op boolean isValidSubId (String subId) {
        return true
    }
}

class OHConfig {
	contains OHTFDevice<?,?>[] ohTfDevices opposite ohConfig
	op OHTFDevice<?,?> getConfigByTFId(String uid, String subid)
	op OHTFDevice<?,?> getConfigByOHId(String ohid)
}

class TFNullConfiguration extends TFConfig {
}

class TFPTCBrickletConfiguration extends TFConfig {
	Short noiseRejectionFilter
	Short wireMode
}

class TFIndustrialDual020mAConfiguration extends TFConfig {
	Short sampleRate
}

class TFBaseConfiguration extends TFConfig {
	BigDecimal threshold
	int callbackPeriod
}

class TFTemperatureConfiguration extends TFBaseConfiguration {
	boolean slowI2C
}
class TFObjectTemperatureConfiguration extends TFBaseConfiguration {
    int emissivity
}

class TFMoistureBrickletConfiguration extends TFBaseConfiguration {
    Short movingAverage
}

class TFDistanceUSBrickletConfiguration extends TFBaseConfiguration {
    Short movingAverage
}

class TFVoltageCurrentConfiguration extends TFConfig {
    Short averaging
    Short voltageConversionTime
    Short currentConversionTime
}

class TFBrickDCConfiguration extends DimmableConfiguration, TFBaseConfiguration{
	short velocity
	int acceleration
	int pwmFrequency
	String driveMode
}

class TFIOActorConfiguration extends TFConfig{
	String defaultState
	boolean keepOnReconnect
}

class TFInterruptListenerConfiguration extends TFConfig{
	long debouncePeriod
}

class TFIOSensorConfiguration extends TFConfig{
	boolean pullUpResistorEnabled
}

class TFServoConfiguration extends DimmableConfiguration {
	int velocity
	int acceleration
	int servoVoltage
	int pulseWidthMin
	int pulseWidthMax
	int period
	//TODO must be equal for all servos, it is a property of the BrickServo
	// but for now no config could be set for SubdeviceHolders
	int outputVoltage
}

class BrickletRemoteSwitchConfiguration extends TFConfig {
    String typeADevices
    String typeBDevices
    String typeCDevices
}

class RemoteSwitchAConfiguration extends TFConfig{
	Short houseCode
	Short receiverCode
    Short repeats
}

class RemoteSwitchBConfiguration extends DimmableConfiguration {
	Long address
	Short unit
    Short repeats
}

class RemoteSwitchCConfiguration extends TFConfig{
	String systemCode
	Short deviceCode
    Short repeats

}

class MultiTouchDeviceConfiguration extends TFConfig {
    Boolean disableElectrode
}

class BrickletMultiTouchConfiguration extends TFConfig {
    Boolean recalibrate
    Short sensitivity
}

class DimmableConfiguration extends TFConfig {
    BigDecimal minValue
    BigDecimal maxValue
}

class ButtonConfiguration extends TFConfig {
	boolean tactile  = "false"
}

class DualButtonLEDConfiguration extends TFConfig {
	boolean autotoggle = "false"
}

class LEDStripConfiguration extends TFConfig {
	String chiptype
	Integer frameduration
	Long clockfrequency
	String colorMapping
	String subDevices
}

class LEDGroupConfiguration extends TFConfig {
	String leds
}

enum NoSubIds {
	
}

enum IndustrialDigitalInSubIDs {
	IN0, IN1, IN2,IN3
}

enum IndustrialDigitalOutSubIDs {
	OUT0, OUT1, OUT2, OUT3
}

enum IndustrialQuadRelayIDs {
	RELAY0, RELAY1, RELAY2, RELAY3
}

enum ServoSubIDs {
	SERVO0, SERVO1, SERVO2, SERVO3, SERVO4, SERVO5, SERVO6	
}

enum BarometerSubIDs {
	TEMPERATURE
}

enum IO16SubIds {
	INA0, INA1, INA2, INA3, INA4, INA5, INA6, INA7
	INB0, INB1, INB2, INB3, INB4, INB5, INB6, INB7
	OUTA0, OUTA1, OUTA2, OUTA3, OUTA4, OUTA5, OUTA6, OUTA7
	OUTB0, OUTB1, OUTB2, OUTB3, OUTB4, OUTB5, OUTB6, OUTB7
}

enum IO4SubIds {
    IN0, IN1, IN2, IN3, OUT0, OUT1, OUT2, OUT3
}

enum DualRelaySubIds {
	RELAY1, RELAY2
}

enum LCDButtonSubIds {
	BUTTON0, BUTTON1, BUTTON2, BUTTON3
}

enum LCDBacklightSubIds {
	BACKLIGHT
}

enum MultiTouchSubIds {
    ELECTRODE0, ELECTRODE1, ELECTRODE2, ELECTRODE3, ELECTRODE4,
    ELECTRODE5, ELECTRODE6, ELECTRODE7, ELECTRODE8, ELECTRODE9,
    ELECTRODE10, ELECTRODE11, PROXIMITY
}

enum TemperatureIRSubIds {
    OBJECT_TEMPERATURE, AMBIENT_TEMPERATURE
}

enum VoltageCurrentSubIds {
    VOLTAGECURRENT_VOLTAGE, VOLTAGECURRENT_CURRENT, VOLTAGECURRENT_POWER
}

enum ConfigOptsMove {
    RIGHTSPEED, LEFTSPEED, ACCELERATION, DRIVEMODE, PWM
}

enum ConfigOptsDimmable {
    MAX, MIN, STEP
}

enum ConfigOptsSetPoint {
    MAX, MIN
}

enum ConfigOptsSwitchSpeed {
    SPEED
}

enum DCDriveMode {
    BRAKE, COAST
}

enum ConfigOptsServo {
    VELOCITY, ACCELERATION, PULSEWIDTHMIN, PULSEWIDTHMAX,
    PERIOD, POSITION, LEFTPOSITION, RIGHTPOSITION
}

enum DualButtonDevicePosition {
	LEFT, RIGHT
}

enum DualButtonLedSubIds {
	DUALBUTTON_LEFTLED, DUALBUTTON_RIGHTLED
}

enum DualButtonButtonSubIds {
	DUALBUTTON_LEFTBUTTON, DUALBUTTON_RIGHTBUTTON
}

enum JoystickSubIds {
	joystick_xposition, joystick_yposition, joystick_button
}

enum PTCSubIds {
	ptc_temperature, ptc_resistance, ptc_connected
}

enum IndustrialDual020mASubIds {
	sensor0, sensor1
}
